현재 게임을 데모적으로 

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Polar Carver: Neon Chain Reaction</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        #ui { position: absolute; top: 20px; left: 20px; pointer-events: none; mix-blend-mode: difference; }
        #phase-display { font-size: 24px; font-weight: bold; text-transform: uppercase; }
        #intensity-display { font-size: 14px; color: #ff3300; margin-top: 5px; font-weight: bold; }
    </style>
</head>
<body>

<div id="ui">
    <h1>POLAR CARVER</h1>
    <div id="phase-display">PHASE: STABLE</div>
    <div id="intensity-display">GRAVITY INTENSITY: x1.00</div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * [Polar Carver: Neon Chain Reaction]
 * 1. 네온 비주얼 + 모든 무기 충돌 및 종양 폭발 시스템 복구.
 * 2. 종양 파괴 시 주변 벽을 밀어내는 물리 효과 적용.
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const SECTOR_COUNT = 180;     
const EARTH_RADIUS = 50;      
const INITIAL_GRAVITY = 20;   
const PUSH_POWER = 550;       
const BULLET_PUSH_POWER = 60; 
const STAGE_DURATION = 30; 

const MISSILE_EXPLOSION_RADIUS = 15;
const MISSILE_EXPLOSION_FORCE = 250;

const THEMES = [
    { name: "FLESH", inner: [60, 0, 10], outer: [180, 0, 40], neon: "#ff0044" },
    { name: "HEAT", inner: [80, 30, 0], outer: [180, 100, 0], neon: "#ffaa00" },
    { name: "SULFUR", inner: [60, 60, 0], outer: [180, 160, 0], neon: "#ffff00" },
    { name: "TOXIN", inner: [10, 50, 0], outer: [40, 180, 0], neon: "#00ff44" }
];

let width, height, cx, cy, maxScreenDist;
let wallRadius = new Float32Array(SECTOR_COUNT); 
let tumors = []; 
let mouseAngle = 0;
let isFiring = false;
let gameOver = false;
let gameTimeSec = 0; 
let lastTime = 0; 
let particles = [];
let bullets = []; 
let missile = null; 

let missileTimer = 0;
let bulletTimer = 0;
let currentPhaseIdx = 0;
let currentGravity = INITIAL_GRAVITY;
let currentColor = { inner: [...THEMES[0].inner], outer: [...THEMES[0].outer] };

function init() {
    resize();
    for(let i=0; i<SECTOR_COUNT; i++) wallRadius[i] = 500;
    for(let i=0; i<10; i++) spawnTumor();
    window.addEventListener('resize', resize);
    window.addEventListener('mousemove', e => {
        const dx = e.clientX - cx; const dy = e.clientY - cy;
        mouseAngle = Math.atan2(dy, dx);
    });
    window.addEventListener('mousedown', () => isFiring = true);
    window.addEventListener('mouseup', () => isFiring = false);
    requestAnimationFrame(loop);
}

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    cx = width / 2; cy = height / 2;
    maxScreenDist = Math.sqrt(cx*cx + cy*cy) + 100;
}

function spawnTumor() {
    const idx = Math.floor(Math.random() * SECTOR_COUNT);
    tumors.push({ index: idx, hp: 50 });
}

function lerp(start, end, t) { return start + (end - start) * t; }

function update(dt) {
    if (gameOver) return;
    gameTimeSec += dt;

    let newPhaseIdx = Math.floor(gameTimeSec / STAGE_DURATION) % THEMES.length;
    if (newPhaseIdx !== currentPhaseIdx) {
        currentPhaseIdx = newPhaseIdx;
        currentGravity *= 1.5; 
        document.getElementById('intensity-display').innerText = `GRAVITY INTENSITY: x${(currentGravity/INITIAL_GRAVITY).toFixed(2)}`;
    }

    let t = (gameTimeSec % STAGE_DURATION) / STAGE_DURATION;
    const themeA = THEMES[currentPhaseIdx]; 
    const themeB = THEMES[(currentPhaseIdx + 1) % THEMES.length];
    for(let i=0; i<3; i++) {
        currentColor.inner[i] = lerp(themeA.inner[i], themeB.inner[i], t);
        currentColor.outer[i] = lerp(themeA.outer[i], themeB.outer[i], t);
    }
    document.getElementById('phase-display').innerText = `PHASE: ${themeA.name}`;
    document.getElementById('phase-display').style.color = themeA.neon;

    missileTimer += dt;
    if (missileTimer >= 2.5) { missileTimer = 0; fireRandomMissile(); }
    updateMissile(dt);

    bulletTimer += dt;
    if (bulletTimer >= 0.4) { bulletTimer = 0; fireAutoBullet(); }
    updateBullets(dt);

    for (let i = 0; i < SECTOR_COUNT; i++) {
        wallRadius[i] -= currentGravity * dt;
        if (wallRadius[i] < EARTH_RADIUS) gameOver = true;
    }

    if (isFiring) carveWall(dt);
    applySmoothing();
    updateParticles(dt);
    if (Math.random() < 0.015 && tumors.length < 20) spawnTumor();
}

function explodeTumor(idx) {
    const t = tumors[idx];
    const centerIdx = t.index;
    const range = 15;
    for (let i = -range; i <= range; i++) {
        const s = (centerIdx + i + SECTOR_COUNT) % SECTOR_COUNT;
        wallRadius[s] += 100 * (1 - Math.abs(i)/range);
    }
    spawnParticles(wallRadius[centerIdx], centerIdx, '#ffff00', 15, 10);
    tumors.splice(idx, 1);
}

function executeAreaExplosion(centerIdx, dist) {
    let range = MISSILE_EXPLOSION_RADIUS; 
    for (let i = -range; i <= range; i++) {
        let idx = (centerIdx + i + SECTOR_COUNT) % SECTOR_COUNT;
        let falloff = Math.pow(1 - Math.abs(i) / range, 2); 
        wallRadius[idx] += MISSILE_EXPLOSION_FORCE * falloff;
        
        // 폭발 반경 내 종양도 체크하여 연쇄 폭발
        for(let j = tumors.length - 1; j >= 0; j--) {
            if(tumors[j].index === idx) explodeTumor(j);
        }
    }
    spawnParticles(dist, centerIdx, '#ff6600', 25, 20);
}

function fireAutoBullet() {
    let minR = maxScreenDist; let targetIdx = 0;
    for (let i = 0; i < SECTOR_COUNT; i++) {
        if (wallRadius[i] < minR) { minR = wallRadius[i]; targetIdx = i; }
    }
    bullets.push({ angle: targetIdx * (Math.PI * 2 / SECTOR_COUNT), speed: 1200, dist: EARTH_RADIUS, targetIdx: targetIdx });
}

function updateBullets(dt) {
    for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i]; b.dist += b.speed * dt;
        
        // 총알이 종양 근처를 지나는지 체크
        for(let j = tumors.length - 1; j >= 0; j--) {
            if(tumors[j].index === b.targetIdx) {
                let tumorDist = wallRadius[tumors[j].index] + 5;
                if(b.dist > tumorDist - 10 && b.dist < tumorDist + 10) {
                    explodeTumor(j); bullets.splice(i, 1); return;
                }
            }
        }

        if (b.dist >= wallRadius[b.targetIdx]) {
            wallRadius[b.targetIdx] += BULLET_PUSH_POWER; bullets.splice(i, 1);
        }
    }
}

function fireRandomMissile() {
    if (missile) return; 
    const randomAngle = Math.random() * Math.PI * 2;
    missile = {
        x: cx + Math.cos(randomAngle) * EARTH_RADIUS, y: cy + Math.sin(randomAngle) * EARTH_RADIUS,
        vx: Math.cos(randomAngle) * 850, vy: Math.sin(randomAngle) * 850,
        angle: randomAngle < 0 ? randomAngle + Math.PI*2 : randomAngle
    };
}

function updateMissile(dt) {
    if (!missile) return;
    missile.x += missile.vx * dt; missile.y += missile.vy * dt;
    const dist = Math.sqrt(Math.pow(missile.x-cx, 2) + Math.pow(missile.y-cy, 2));
    const angleStep = (Math.PI * 2) / SECTOR_COUNT;
    let sIdx = Math.floor(missile.angle / angleStep) % SECTOR_COUNT;
    if (dist >= wallRadius[sIdx] + 15) { executeAreaExplosion(sIdx, dist); missile = null; }
}

function carveWall(dt) {
    const angleStep = (Math.PI * 2) / SECTOR_COUNT;
    let aim = mouseAngle; if (aim < 0) aim += Math.PI * 2;
    const centerIdx = Math.floor(aim / angleStep) % SECTOR_COUNT;

    for (let i = -4; i <= 4; i++) {
        let idx = (centerIdx + i + SECTOR_COUNT) % SECTOR_COUNT;
        wallRadius[idx] += PUSH_POWER * (1 - Math.abs(i)/5) * dt;
        
        // 레이저가 종양 타격 체크
        for (let j = tumors.length - 1; j >= 0; j--) {
            if (tumors[j].index === idx) {
                tumors[j].hp -= 200 * dt; 
                if (tumors[j].hp <= 0) explodeTumor(j);
            }
        }
    }
    if (Math.random() > 0.4) spawnParticles(wallRadius[centerIdx], centerIdx, '#00ffff', 2, 8);
}

function applySmoothing() {
    let newRadius = new Float32Array(SECTOR_COUNT);
    for (let i = 0; i < SECTOR_COUNT; i++) {
        let prev = (i - 1 + SECTOR_COUNT) % SECTOR_COUNT;
        let next = (i + 1) % SECTOR_COUNT;
        newRadius[i] = wallRadius[i] * 0.9 + (wallRadius[prev] + wallRadius[next]) * 0.05;
    }
    wallRadius.set(newRadius);
}

function updateParticles(dt) {
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].life -= dt * 2.5;
        particles[i].x += particles[i].vx; particles[i].y += particles[i].vy;
        if (particles[i].life <= 0) particles.splice(i, 1);
    }
}

function spawnParticles(dist, sectorIdx, color, count, speed = 12) {
    const angle = sectorIdx * (Math.PI * 2 / SECTOR_COUNT);
    const px = cx + Math.cos(angle) * dist; const py = cy + Math.sin(angle) * dist;
    for(let i=0; i<count; i++) {
        particles.push({ x: px, y: py, vx: (Math.random()-0.5) * speed, vy: (Math.random()-0.5) * speed, life: 1.0, color: color });
    }
}

function rgbStr(arr) { return `rgb(${Math.floor(arr[0])}, ${Math.floor(arr[1])}, ${Math.floor(arr[2])})`; }

function draw() {
    ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, width, height);
    if (gameOver) {
        ctx.fillStyle = '#f33'; ctx.font = '30px Courier New'; ctx.textAlign = 'center';
        ctx.fillText("CORE CONSUMED", cx, cy); return;
    }
    const angleStep = (Math.PI * 2) / SECTOR_COUNT;
    
    ctx.save();
    let grd = ctx.createRadialGradient(cx, cy, EARTH_RADIUS, cx, cy, maxScreenDist);
    grd.addColorStop(0, rgbStr(currentColor.inner)); 
    grd.addColorStop(1, rgbStr(currentColor.outer)); 
    ctx.fillStyle = grd; ctx.fillRect(0, 0, width, height);

    ctx.globalCompositeOperation = 'destination-out';
    ctx.beginPath();
    for (let i = 0; i <= SECTOR_COUNT; i++) {
        let r = wallRadius[i % SECTOR_COUNT]; let a = i * angleStep;
        if (i === 0) ctx.moveTo(cx + Math.cos(a) * r, cy + Math.sin(a) * r);
        else ctx.lineTo(cx + Math.cos(a) * r, cy + Math.sin(a) * r);
    }
    ctx.fill(); ctx.restore();

    // 1. 네온 경계선
    ctx.save();
    ctx.beginPath();
    for (let i = 0; i <= SECTOR_COUNT; i++) {
        let r = wallRadius[i % SECTOR_COUNT]; let a = i * angleStep;
        if (i === 0) ctx.moveTo(cx + Math.cos(a) * r, cy + Math.sin(a) * r);
        else ctx.lineTo(cx + Math.cos(a) * r, cy + Math.sin(a) * r);
    }
    ctx.strokeStyle = THEMES[currentPhaseIdx].neon;
    ctx.lineWidth = 3;
    ctx.shadowBlur = 20;
    ctx.shadowColor = THEMES[currentPhaseIdx].neon;
    ctx.stroke();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    ctx.shadowBlur = 0;
    ctx.stroke();
    ctx.restore();

    // 2. 종양 (노란색 네온)
    for (let t of tumors) {
        let a = t.index * angleStep; let r = wallRadius[t.index] + 4; 
        ctx.beginPath(); ctx.arc(cx + Math.cos(a) * r, cy + Math.sin(a) * r, 6, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#ffff00';
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    ctx.beginPath(); ctx.arc(cx, cy, EARTH_RADIUS, 0, Math.PI * 2);
    ctx.fillStyle = '#000'; ctx.fill();
    ctx.strokeStyle = '#fff'; ctx.stroke();

    // 3. 네온 레이저
    if (isFiring) {
        let sIdx = Math.floor(((mouseAngle < 0 ? mouseAngle + Math.PI*2 : mouseAngle) / angleStep)) % SECTOR_COUNT;
        ctx.save();
        ctx.beginPath(); ctx.moveTo(cx, cy);
        ctx.lineTo(cx + Math.cos(mouseAngle) * wallRadius[sIdx], cy + Math.sin(mouseAngle) * wallRadius[sIdx]);
        ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 4;
        ctx.shadowBlur = 25; ctx.shadowColor = '#00ffff';
        ctx.stroke();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.5;
        ctx.stroke();
        ctx.restore();
    }

    for(let b of bullets) {
        ctx.beginPath(); ctx.arc(cx + Math.cos(b.angle)*b.dist, cy + Math.sin(b.angle)*b.dist, 2, 0, Math.PI*2);
        ctx.fillStyle = '#ff0'; ctx.fill();
    }
    if (missile) {
        ctx.beginPath(); ctx.arc(missile.x, missile.y, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#f60'; ctx.fill();
    }
    for(let p of particles){ ctx.fillStyle = p.color; ctx.globalAlpha = p.life; ctx.fillRect(p.x, p.y, 2, 2); }
    ctx.globalAlpha = 1.0;
}

function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const dt = Math.min(0.1, (timestamp - lastTime) / 1000);
    lastTime = timestamp; update(dt); draw(); requestAnimationFrame(loop);
}
init();
</script>
</body>
</html>

이렇게 구축해봤다. 